library(XML)

# See MarkLundy/readPDF2HTML.R
# Create the class hierarchy for a document generated by our modified pdftohtml.
setOldClass(c("PDFToXMLDoc", "ConvertedPDFDoc", "XMLInternalDocument", "XMLAbstractDocument"))
setOldClass(c("PDFToXMLPage", "ConvertedPDFPage", "XMLInternalElement", "XMLInternalNode", "XMLAbstractNode"))

pdftohtmlDoc =
    #
    # read an XML or a PDF document. If it is XML, it is assumed to be
    # already converted by pdftohtml. If it is a PDF document, we convert it.
    #
function(file)
{
   if(grepl("\\.pdf$", file))
      convertPDF2XML(file)
   else {
      doc = xmlParse(file)
      class(doc) = c("PDFToXMLDoc", "ConvertedPDFDoc", class(doc))
      doc
   }
}

showPage =
    # toplevel function.  Provide a file and a page number, and we render that page.
function(f, pageNum = 1, doc = xmlParse(f), page = getNodeSet(doc, "//page")[[pageNum]], ...)
{
  if(is(f, "XMLInternalDocument") && missing(doc))
      doc = f
  else if(missing(pageNum) && is(f, "XMLInternalElementNode") && xmlName(f) == "page")
      page = f
  
  renderPage(page, ...)
}

plot.PDFToXMLPage = showPage
    

renderPage =
    #
    # Give us the page and we draw its elements - line, rect, img, text
    # The text is not proportional so is often much shorter in the horizontal direction
    # than it would be when displayed as PDF.
    #
    # No color information on the text nodes at this point.
    #
function(page, cex.text = .5, adj = c(0, 1), showText = TRUE, showBoxes = FALSE) # , showColors = TRUE)
{    
    p = page
    psize = as.integer(xmlAttrs(p)[c("height", "width")])
    h = psize[1]

    plot(0, type = "n", xlab = "", ylab = "", xlim = c(0, psize[2]), ylim = c(0, psize[1]))
    title(sprintf("%s, page %s", URLdecode(docName(page)), xmlGetAttr(page, "number")))
    
    rr = getNodeSet(page, ".//rect ")
    if(length(rr)) {
        bb = getBBox(rr)
        col = sapply(rr, function(x) mkColor(xmlGetAttr(x, "fill.color", "0,0,0"), isFill = TRUE))
        lwd = max(1, as.numeric(sapply(rr, function(x) xmlGetAttr(x, "lineWidth", "1.0"))))
        rect(bb[,1], h - bb[,2], bb[,3], h - bb[,4], border = "green", col = col, lwd = lwd)
    }

    if(length ( lines <- getNodeSet(page, ".//line "))) {
        bb = getBBox(lines)
        sapply(1:nrow(bb),
                function(i) {
                     at = xmlAttrs(lines[[i]])
                     lines(bb[i, c(1,3)], h - bb[i, c(2, 4)], col = mkColor(at["stroke.color"]),
                               lwd = max(1, as.numeric(at["lineWidth"], na.rm = TRUE)))
                })
        # lines(bb[,1], h - bb[,2], bb[,3], h-bb[,4], col = "red")
    }

    
    imgs = getNodeSet(page, ".//img")
    if(length(imgs)) {
        bb = getBBox2(imgs, attrs = c("x", "y"))

        #XXX??? Should these y values be subtracted from h???
        # And are these widths and heights that need to be added!
        rect(bb[,1], h - bb[,2], bb[,1] + bb[,3], h - bb[,4] - bb[,4], border = "blue", lty = 3)
    }    

    if(showText) {
        txt = getNodeSet(page, ".//text")
        if(length(txt)) {
            bb = t(sapply(txt, xmlAttrs))
            storage.mode(bb) = "double"

            
            colors = getNodeColors(txt)
            text = sapply(txt, xmlValue)
            by(1:nrow(bb), bb[, "rotation"],
               function(i)
                 text(bb[i,2], h - bb[i,1], text[i], cex = cex.text, adj = adj, col = colors[i], srt = - bb[i[1], "rotation"])) 
        }
    }

    if(showBoxes) {
        txt = getNodeSet(page, ".//text")
        bb = getBBox2(txt)

        rect(bb[,1], h - bb[,2], bb[,1] + bb[,3], h - bb[,2] - bb[,4], border = "lightgreen")
    }

    TRUE
}


getNodeColors =
function(textNodes, fonts = getFontInfo(xmlParent(textNodes[[1]])))
{
    f = sapply(textNodes, xmlGetAttr, "font")
    fonts$color[ match(f, fonts$id) ]
}

mkColor =
    # Convert a triple of RGB values as a string into  a color
    # assuming a maxColorValue of 2^16
    # This could be, but is not vectorized.
function(x, alpha = maxColorValue, maxColorValue = 2^16,  isFill = FALSE)
{
   if(is.null(x) || x == "" || is.na(x))
       return(rgb(0, 0, 0))
    
   els = as.integer(strsplit(x, ",")[[1]])
   if(isFill && all(els == 0))
       NA
   else
       rgb(els[1], els[2], els[3], alpha, maxColorValue = maxColorValue)
}







